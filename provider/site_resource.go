// Copyright 2025, Justin Detmar.
// SPDX-License-Identifier: MIT
//
// This is an unofficial, community-maintained Pulumi provider for Webflow.
// Not affiliated with, endorsed by, or supported by Pulumi Corporation or Webflow, Inc.

package provider

import (
	"context"
	"errors"
	"fmt"
	"time"

	p "github.com/pulumi/pulumi-go-provider"
	"github.com/pulumi/pulumi-go-provider/infer"
)

// SiteResource is the resource controller for managing Webflow sites.
// It implements the infer.CustomResource interface for full CRUD operations.
type SiteResource struct{}

// SiteArgs defines the input properties for the Site resource.
type SiteArgs struct {
	// WorkspaceID is the Webflow workspace ID where the site will be created.
	// Required for site creation operations - Enterprise workspace is required by Webflow API.
	// Example: "5f0c8c9e1c9d440000e8d8c3"
	WorkspaceID string `pulumi:"workspaceId"`
	// DisplayName is the human-readable name of the site shown in the Webflow dashboard.
	// Required - must be a non-empty string.
	// Examples: "My Marketing Site", "Company Blog", "Product Landing Page"
	DisplayName string `pulumi:"displayName"`
	// ShortName is the slugified version of the site name used in URLs.
	// Optional - if not provided, Webflow will generate one from displayName.
	// Must be lowercase alphanumeric with hyphens only (no spaces, underscores, or special characters).
	// Examples: "my-site", "company-blog-2024", "product-landing"
	ShortName string `pulumi:"shortName,optional"`
	// TimeZone is the IANA timezone identifier for the site.
	// Optional - defaults to Webflow's default timezone if not specified.
	// Examples: "America/New_York", "Europe/London", "Asia/Tokyo", "UTC"
	TimeZone string `pulumi:"timeZone,optional"`
	// ParentFolderID is the folder ID where the site will be organized in the Webflow dashboard.
	// Optional - site will be placed at workspace root if not specified.
	ParentFolderID string `pulumi:"parentFolderId,optional"`
	// Publish triggers automatic site publishing after create/update.
	// When set to true, the provider will publish the site to production after successfully creating or updating it.
	// Default: false (manual publishing required).
	// Note: Site must have at least one published version before automatic publishing will work.
	// Optional - defaults to false.
	Publish bool `pulumi:"publish,optional"`
	// TemplateName is the template to use for site creation.
	// Optional - used only during site creation, cannot be changed after creation (IMMUTABLE).
	// WARNING: Changing this value will DELETE the existing site and CREATE a new one (DESTRUCTIVE).
	// Examples: "mast-framework", "blank", or any other Webflow template identifier.
	TemplateName string `pulumi:"templateName,optional"`
}

// SiteState defines the output properties for the Site resource.
// It embeds SiteArgs to include input properties in the output.
type SiteState struct {
	SiteArgs
	// LastPublished is the timestamp of the last site publish (read-only).
	// Set automatically by Webflow when the site is published.
	LastPublished string `pulumi:"lastPublished,optional"`
	// LastUpdated is the timestamp of the last site update (read-only).
	// Set automatically by Webflow when the site configuration changes.
	LastUpdated string `pulumi:"lastUpdated,optional"`
	// PreviewURL is the URL to a preview image of the site (read-only).
	// Automatically generated by Webflow for site thumbnails.
	PreviewURL string `pulumi:"previewUrl,optional"`
	// CustomDomains is the list of custom domains attached to the site (read-only for now).
	// Custom domain management is out of scope for the MVP.
	CustomDomains []string `pulumi:"customDomains,optional"`
	// DataCollectionEnabled indicates if data collection is enabled for the site (read-only).
	// Controlled by Webflow workspace settings.
	DataCollectionEnabled bool `pulumi:"dataCollectionEnabled,optional"`
	// DataCollectionType is the type of data collection enabled (read-only).
	// Values: always, optOut, disabled. Controlled by Webflow workspace settings.
	DataCollectionType string `pulumi:"dataCollectionType,optional"`
}

// Annotate adds descriptions and constraints to the Site resource.
func (r *SiteResource) Annotate(a infer.Annotator) {
	a.SetToken("index", "Site")
	a.Describe(r, "Manages Webflow sites programmatically. "+
		"This resource allows you to create, configure, and manage Webflow sites through infrastructure code. "+
		"Create, Read, Update, and Delete operations are fully supported for complete site lifecycle management.")
}

// Annotate adds descriptions to the SiteArgs fields.
func (args *SiteArgs) Annotate(a infer.Annotator) {
	a.Describe(&args.WorkspaceID,
		"The Webflow workspace ID where the site will be created. "+
			"Required for site creation (Enterprise workspace required by Webflow API). "+
			"Example: '5f0c8c9e1c9d440000e8d8c3'. "+
			"You can find your workspace ID in the Webflow dashboard under Account Settings > Workspace.")

	a.Describe(&args.DisplayName,
		"The human-readable name of the site as shown in the Webflow dashboard. "+
			"Required - must be a non-empty string. "+
			"Examples: 'My Marketing Site', 'Company Blog', 'Product Landing Page'. "+
			"This is the name users will see when managing the site.")

	a.Describe(&args.ShortName,
		"The slugified version of the site name used in URLs and for file organization. "+
			"Optional - if not provided, Webflow will automatically generate one from the displayName. "+
			"Must use only lowercase letters (a-z), numbers (0-9), and hyphens (-). "+
			"No spaces, underscores, or special characters allowed. "+
			"Must start and end with a letter or number (no leading/trailing hyphens). "+
			"Examples: 'my-site', 'company-blog-2024', 'product-landing-page'.")

	a.Describe(&args.TimeZone,
		"The IANA timezone identifier for the site. "+
			"Optional - Webflow will use its default timezone if not specified. "+
			"Use standard IANA timezone identifiers (e.g., 'America/New_York', 'Europe/London', 'Asia/Tokyo', 'UTC'). "+
			"This timezone is used for scheduling, analytics, and other time-sensitive features.")

	a.Describe(&args.ParentFolderID,
		"The folder ID where the site will be organized in the Webflow dashboard. "+
			"Optional - the site will be placed at the workspace root if not specified. "+
			"This is useful for organizing multiple sites into logical groups within your workspace.")

	a.Describe(&args.Publish,
		"Automatically publish the site after creation or updates. "+
			"When set to true, the provider will publish the site to production after "+
			"successfully creating or updating it. "+
			"Default: false (manual publishing required). "+
			"Note: Site must have at least one published version before automatic "+
			"publishing will work. "+
			"If publishing fails, the entire operation will fail with an error "+
			"(site may exist but Pulumi will report failure). "+
			"Recommendation: Set to false for initial site creation, then enable "+
			"after first manual publish.")

	a.Describe(&args.TemplateName,
		"The template to use for site creation. "+
			"Optional - if not specified, Webflow will create a blank site. "+
			"**WARNING: This field is IMMUTABLE.** Once set, it cannot be changed. "+
			"Changing this value will trigger a REPLACE operation, which will: "+
			"(1) DELETE your existing site and ALL its content (pages, CMS items, assets, etc.), "+
			"(2) CREATE a new site with the new template, "+
			"(3) REPLACE all dependent resources (redirects, robots.txt, etc.). "+
			"This is a DESTRUCTIVE operation that cannot be undone. "+
			"Use any valid Webflow template identifier (e.g., 'mast-framework', 'blank'). "+
			"Consider using resource protection (`protect: true`) to prevent accidental replacement.")
}

// Annotate adds descriptions to the SiteState fields.
func (state *SiteState) Annotate(a infer.Annotator) {
	a.Describe(&state.LastPublished,
		"The RFC3339 timestamp of the last time the site was published (read-only). "+
			"Automatically set by Webflow when changes are published to production.")

	a.Describe(&state.LastUpdated,
		"The RFC3339 timestamp of the last time the site configuration was updated (read-only). "+
			"Automatically set by Webflow when any site changes occur.")

	a.Describe(&state.PreviewURL,
		"The URL to a preview image of the site (read-only). "+
			"Automatically generated by Webflow for site thumbnails in the dashboard.")

	a.Describe(&state.CustomDomains,
		"List of custom domains attached to the site (read-only in this release). "+
			"Custom domain management will be available in a future release.")

	a.Describe(&state.DataCollectionEnabled,
		"Indicates whether data collection is enabled for this site (read-only). "+
			"Controlled by your Webflow workspace settings, not per-site.")

	a.Describe(&state.DataCollectionType,
		"The type of data collection enabled for the site (read-only). "+
			"Possible values: 'always' (always collect), 'optOut' (collect by default), 'disabled' (no collection). "+
			"Controlled by your Webflow workspace settings, not per-site.")
}

// Diff determines what changes need to be made to the site resource.
// For sites, workspace ID and site ID are immutable (primary key).
// Other fields (displayName, timeZone, etc.) can be updated.
func (r *SiteResource) Diff(
	ctx context.Context, req infer.DiffRequest[SiteArgs, SiteState],
) (infer.DiffResponse, error) {
	diff := infer.DiffResponse{
		DeleteBeforeReplace: false,
		HasChanges:          false,
		DetailedDiff:        make(map[string]p.PropertyDiff),
	}

	// Check immutable fields (workspaceId, templateName) - require replace if changed
	if req.Inputs.WorkspaceID != req.State.WorkspaceID {
		diff.HasChanges = true
		diff.DeleteBeforeReplace = false
		diff.DetailedDiff["workspaceId"] = p.PropertyDiff{
			Kind: p.UpdateReplace,
		}
		// If workspace changes, entire resource must be replaced
		return diff, nil
	}

	if req.Inputs.TemplateName != req.State.TemplateName {
		diff.HasChanges = true
		diff.DeleteBeforeReplace = false
		diff.DetailedDiff["templateName"] = p.PropertyDiff{
			Kind: p.UpdateReplace,
		}
		// If template changes, entire resource must be replaced
		return diff, nil
	}

	// Check mutable fields - can be updated in place
	// CRITICAL: Accumulate all changes in SINGLE map (don't overwrite!)

	if req.Inputs.DisplayName != req.State.DisplayName {
		diff.HasChanges = true
		diff.DetailedDiff["displayName"] = p.PropertyDiff{
			Kind: p.Update,
		}
	}

	// Only report shortName change if user explicitly specified it.
	// An empty input means "I don't care about this field" not "remove it".
	// This prevents phantom updates when API returns a value user didn't set.
	if req.Inputs.ShortName != "" && req.Inputs.ShortName != req.State.ShortName {
		diff.HasChanges = true
		diff.DetailedDiff["shortName"] = p.PropertyDiff{
			Kind: p.Update,
		}
	}

	if req.Inputs.TimeZone != req.State.TimeZone {
		diff.HasChanges = true
		diff.DetailedDiff["timeZone"] = p.PropertyDiff{
			Kind: p.Update,
		}
	}

	if req.Inputs.ParentFolderID != req.State.ParentFolderID {
		diff.HasChanges = true
		diff.DetailedDiff["parentFolderId"] = p.PropertyDiff{
			Kind: p.Update,
		}
	}

	if req.Inputs.Publish != req.State.Publish {
		diff.HasChanges = true
		diff.DetailedDiff["publish"] = p.PropertyDiff{
			Kind: p.Update,
		}
	}

	return diff, nil
}

// Create creates a new site in Webflow.
func (r *SiteResource) Create(
	ctx context.Context, req infer.CreateRequest[SiteArgs],
) (infer.CreateResponse[SiteState], error) {
	// Log the start of site creation
	log := NewLogContext(ctx).
		WithField("workspaceId", req.Inputs.WorkspaceID).
		WithField("displayName", req.Inputs.DisplayName).
		WithField("shortName", req.Inputs.ShortName)
	log.Info("Creating Webflow site")

	// Step 1: Validate inputs BEFORE any operations
	if err := ValidateWorkspaceID(req.Inputs.WorkspaceID); err != nil {
		log.Errorf("Validation failed: %v", err)
		return infer.CreateResponse[SiteState]{}, fmt.Errorf("validation failed for Site resource: %w", err)
	}
	if err := ValidateDisplayName(req.Inputs.DisplayName); err != nil {
		log.Errorf("Validation failed: %v", err)
		return infer.CreateResponse[SiteState]{}, fmt.Errorf("validation failed for Site resource: %w", err)
	}
	if err := ValidateShortName(req.Inputs.ShortName); err != nil {
		log.Errorf("Validation failed: %v", err)
		return infer.CreateResponse[SiteState]{}, fmt.Errorf("validation failed for Site resource: %w", err)
	}
	if err := ValidateTimeZone(req.Inputs.TimeZone); err != nil {
		log.Errorf("Validation failed: %v", err)
		return infer.CreateResponse[SiteState]{}, fmt.Errorf("validation failed for Site resource: %w", err)
	}

	// Step 2: Initialize state from inputs
	state := SiteState{
		SiteArgs: req.Inputs,
		// Read-only fields will be populated from API response
	}

	// Step 3: Handle DryRun mode (preview without API call)
	if req.DryRun {
		log.Debug("Dry run mode - skipping API call")
		// Return preview state with preview ID
		// Use consistent "preview-" prefix format for dry-run previews
		previewID := fmt.Sprintf("preview-%d", time.Now().Unix())
		return infer.CreateResponse[SiteState]{
			ID:     previewID,
			Output: state,
		}, nil
	}

	// Step 4: Get authenticated HTTP client
	client, err := GetHTTPClient(ctx, providerVersion)
	if err != nil {
		log.Errorf("Failed to create HTTP client: %v", err)
		return infer.CreateResponse[SiteState]{}, fmt.Errorf("failed to create HTTP client: %w", err)
	}

	// Step 5: Call Webflow API to create site
	log.Debug("Calling Webflow API to create site")
	response, err := PostSite(
		ctx, client,
		req.Inputs.WorkspaceID, req.Inputs.DisplayName,
		req.Inputs.ParentFolderID, req.Inputs.TemplateName,
	)
	if err != nil {
		log.Errorf("Failed to create site via API: %v", err)
		return infer.CreateResponse[SiteState]{}, fmt.Errorf("failed to create site: %w", err)
	}

	// Step 6: Defensive check - ensure API returned valid site ID
	if response.ID == "" {
		log.Error("API returned empty site ID")
		return infer.CreateResponse[SiteState]{}, errors.New(
			"webflow API returned empty site ID - " +
				"this is unexpected and may indicate an API issue")
	}

	log.WithField("siteId", response.ID).Info("Site created successfully")

	// Step 7: Populate state with API response data
	state.LastPublished = response.LastPublished
	state.LastUpdated = response.LastUpdated
	state.PreviewURL = response.PreviewURL
	// Note: CustomDomains, DataCollectionEnabled, DataCollectionType are read-only workspace settings
	// We don't populate them from user inputs, only from API responses
	if response.CustomDomains != nil {
		state.CustomDomains = response.CustomDomains
	}
	state.DataCollectionEnabled = response.DataCollectionEnabled
	state.DataCollectionType = response.DataCollectionType

	// Step 8: Optionally publish site after creation
	if req.Inputs.Publish {
		log.WithField("siteId", response.ID).Debug("Publishing site after creation")
		if _, err := PublishSite(ctx, client, response.ID, nil); err != nil {
			// Site was created successfully, publishing is optional enhancement
			// Return error message explaining what succeeded and what failed
			log.WithField("siteId", response.ID).Errorf("Publishing failed: %v", err)
			return infer.CreateResponse[SiteState]{}, fmt.Errorf("site created successfully but publishing failed: %w", err)
		}
		log.WithField("siteId", response.ID).Info("Site published successfully")
	}

	// Step 9: Return successful response with siteId as resource ID
	return infer.CreateResponse[SiteState]{
		ID:     response.ID,
		Output: state,
	}, nil
}

// Read retrieves the current state of a site from Webflow.
// This is called by Pulumi during preview, refresh, update, and IMPORT operations to detect drift.
// If the site was deleted externally, Read returns empty inputs to signal deletion.
//
// Import Support: Accepts siteId directly
// Example: pulumi import webflow:index:Site my-site "69307a0ff82ccd49b929ed6d"
// The workspaceId is automatically fetched from the Webflow API.
func (r *SiteResource) Read(
	ctx context.Context, req infer.ReadRequest[SiteArgs, SiteState],
) (infer.ReadResponse[SiteArgs, SiteState], error) {
	// Get authenticated HTTP client
	client, err := GetHTTPClient(ctx, providerVersion)
	if err != nil {
		return infer.ReadResponse[SiteArgs, SiteState]{}, fmt.Errorf("failed to get HTTP client: %w", err)
	}

	// Resource ID is just the siteId
	siteID := req.ID

	// Call GetSite API - only needs siteId, returns workspaceId
	siteData, err := GetSite(ctx, client, siteID)
	if err != nil {
		return infer.ReadResponse[SiteArgs, SiteState]{}, fmt.Errorf("failed to read site (site ID: %s): %w", siteID, err)
	}

	// Handle site not found (404) - site was deleted externally
	if siteData == nil {
		// Return empty inputs to signal deletion to Pulumi
		// Pulumi will mark this resource for recreation or removal from state
		return infer.ReadResponse[SiteArgs, SiteState]{
			Inputs: SiteArgs{},
			State: SiteState{
				SiteArgs: SiteArgs{},
			},
		}, nil
	}

	// Map API response to SiteState
	// WorkspaceID is fetched from the API response
	currentInputs := SiteArgs{
		WorkspaceID:    siteData.WorkspaceID,
		DisplayName:    siteData.DisplayName,
		ShortName:      siteData.ShortName,
		TimeZone:       siteData.TimeZone,
		ParentFolderID: siteData.ParentFolderID,
		// Publish property is not returned by GET API - preserve existing value
		Publish: req.State.Publish,
	}

	currentState := SiteState{
		SiteArgs:              currentInputs,
		LastPublished:         siteData.LastPublished,
		LastUpdated:           siteData.LastUpdated,
		PreviewURL:            siteData.PreviewURL,
		CustomDomains:         siteData.CustomDomains,
		DataCollectionEnabled: siteData.DataCollectionEnabled,
		DataCollectionType:    siteData.DataCollectionType,
	}

	// Return current inputs and state with siteId as resource ID
	// Pulumi will compare currentInputs with code-defined inputs for drift detection
	return infer.ReadResponse[SiteArgs, SiteState]{
		ID:     siteID,
		Inputs: currentInputs,
		State:  currentState,
	}, nil
}

// Update modifies an existing site configuration.
func (r *SiteResource) Update(
	ctx context.Context, req infer.UpdateRequest[SiteArgs, SiteState],
) (infer.UpdateResponse[SiteState], error) {
	// Step 1: Resource ID is just the siteId
	siteID := req.ID

	// Log the start of site update
	log := NewLogContext(ctx).
		WithField("siteId", siteID).
		WithField("displayName", req.Inputs.DisplayName)
	log.Info("Updating Webflow site")

	// Step 2: Validate all inputs BEFORE any operations
	if err := ValidateDisplayName(req.Inputs.DisplayName); err != nil {
		log.Errorf("Validation failed: %v", err)
		return infer.UpdateResponse[SiteState]{}, fmt.Errorf("validation failed for Site resource: %w", err)
	}
	if err := ValidateShortName(req.Inputs.ShortName); err != nil {
		log.Errorf("Validation failed: %v", err)
		return infer.UpdateResponse[SiteState]{}, fmt.Errorf("validation failed for Site resource: %w", err)
	}
	if err := ValidateTimeZone(req.Inputs.TimeZone); err != nil {
		log.Errorf("Validation failed: %v", err)
		return infer.UpdateResponse[SiteState]{}, fmt.Errorf("validation failed for Site resource: %w", err)
	}

	// Step 3: Initialize state with current inputs
	state := SiteState{
		SiteArgs: req.Inputs,
		// Preserve read-only fields from previous state
		LastPublished:         req.State.LastPublished,
		LastUpdated:           req.State.LastUpdated,
		PreviewURL:            req.State.PreviewURL,
		CustomDomains:         req.State.CustomDomains,
		DataCollectionEnabled: req.State.DataCollectionEnabled,
		DataCollectionType:    req.State.DataCollectionType,
	}

	// Step 4: Handle DryRun mode (preview without API call)
	if req.DryRun {
		log.Debug("Dry run mode - skipping API call")
		return infer.UpdateResponse[SiteState]{
			Output: state,
		}, nil
	}

	// Step 5: Get authenticated HTTP client
	client, err := GetHTTPClient(ctx, providerVersion)
	if err != nil {
		log.Errorf("Failed to create HTTP client: %v", err)
		return infer.UpdateResponse[SiteState]{}, fmt.Errorf("failed to create HTTP client: %w", err)
	}

	// Step 6: Call Webflow API to update site
	log.Debug("Calling Webflow API to update site")
	// Note: We send all fields, API will handle which ones actually changed
	response, err := PatchSite(ctx, client, siteID, req.Inputs.DisplayName, req.Inputs.ShortName, req.Inputs.TimeZone)
	if err != nil {
		log.Errorf("Failed to update site via API: %v", err)
		return infer.UpdateResponse[SiteState]{}, fmt.Errorf("failed to update site: %w", err)
	}

	log.Info("Site updated successfully")

	// Step 7: Update state with API response (API returns full site object)
	state.DisplayName = response.DisplayName
	state.ShortName = response.ShortName
	state.TimeZone = response.TimeZone
	state.LastPublished = response.LastPublished
	state.LastUpdated = response.LastUpdated
	state.PreviewURL = response.PreviewURL
	if response.CustomDomains != nil {
		state.CustomDomains = response.CustomDomains
	}
	state.DataCollectionEnabled = response.DataCollectionEnabled
	state.DataCollectionType = response.DataCollectionType

	// Step 8: Optionally publish site after update
	if req.Inputs.Publish {
		log.Debug("Publishing site after update")
		if _, err := PublishSite(ctx, client, siteID, nil); err != nil {
			// Site was updated successfully, publishing is optional enhancement
			// Return error message explaining what succeeded and what failed
			log.Errorf("Publishing failed: %v", err)
			return infer.UpdateResponse[SiteState]{}, fmt.Errorf("site updated successfully but publishing failed: %w", err)
		}
		log.Info("Site published successfully")
	}

	// Step 9: Return successful response
	return infer.UpdateResponse[SiteState]{
		Output: state,
	}, nil
}

// Delete removes a site from Webflow.
// This is a destructive operation that permanently deletes the site and all its content.
// The operation cannot be undone.
func (r *SiteResource) Delete(ctx context.Context, req infer.DeleteRequest[SiteState]) (infer.DeleteResponse, error) {
	// Resource ID is just the siteId
	siteID := req.ID

	// Log the start of site deletion
	log := NewLogContext(ctx).
		WithField("siteId", siteID).
		WithField("displayName", req.State.DisplayName)
	log.Warn("Deleting Webflow site - this is a destructive operation")

	// Get HTTP client
	client, err := GetHTTPClient(ctx, providerVersion)
	if err != nil {
		log.Errorf("Failed to create HTTP client: %v", err)
		return infer.DeleteResponse{}, fmt.Errorf("failed to create HTTP client: %w", err)
	}

	// Call DeleteSite API (handles 404 gracefully for idempotency)
	log.Debug("Calling Webflow API to delete site")
	if err := DeleteSite(ctx, client, siteID); err != nil {
		log.Errorf("Failed to delete site via API: %v", err)
		return infer.DeleteResponse{}, fmt.Errorf("failed to delete site (site ID: %s): %w", siteID, err)
	}

	log.Info("Site deleted successfully")

	// Success - site deleted from Webflow
	// Pulumi will automatically remove from state
	return infer.DeleteResponse{}, nil
}
